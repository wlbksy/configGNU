{
    "iostream": {
        "prefix": "#include <iostream>",
        "body": [
            "#include <iostream>",
            "$0"
        ]
    },
    "algorithm": {
        "prefix": "#include <algorithm>",
        "body": [
            "#include <algorithm>",
            "$0"
        ]
    },
    "cmath": {
        "prefix": "#include <cmath>",
        "body": [
            "#include <cmath>",
            "$0"
        ]
    },
    "cstring": {
        "prefix": "#include <cstring>",
        "body": [
            "#include <cstring>",
            "$0"
        ]
    },
    "vector": {
        "prefix": "#include <vector>",
        "body": [
            "#include <vector>",
            "$0"
        ]
    },
    "map": {
        "prefix": "#include <map>",
        "body": [
            "#include <map>",
            "$0"
        ]
    },
    "unordered_map": {
        "prefix": "#include <unordered_map>",
        "body": [
            "#include <unordered_map>",
            "$0"
        ]
    },
    "set": {
        "prefix": "#include <set>",
        "body": [
            "#include <set>",
            "$0"
        ]
    },
    "unordered_set": {
        "prefix": "#include <unordered_set>",
        "body": [
            "#include <unordered_set>",
            "$0"
        ]
    },
    "queue": {
        "prefix": "#include <queue>",
        "body": [
            "#include <queue>",
            "$0"
        ]
    },
    "4方向偏移量": {
        "prefix": [
            "dir4"
        ],
        "body": [
            "int dx[8] = {-1, 0, 1, 0};",
            "int dy[8] = {0, 1, 0, -1};",
            "$0"
        ]
    },
    "8方向偏移量": {
        "prefix": [
            "dir8"
        ],
        "body": [
            "int dx[8] = {-1, -1, -1, 0, 1, 1, 1, 0};",
            "int dy[8] = {-1, 0, 1, 1, 1, 0, -1, -1};",
            "$0"
        ],
        "description": "8方向偏移量"
    },
    "日字形偏移量": {
        "prefix": [
            "dir_ri"
        ],
        "body": [
            "int dx[8] = {-2, -1, 1, 2, 2, 1, -1, -2};",
            "int dy[8] = {1, 2, 2, 1, -1, -2, -2, -1};",
            "$0"
        ]
    },
    "main": {
        "prefix": "int main()",
        "body": [
            "using namespace std;",
            "",
            "int main() {",
            "\t$0",
            "",
            "\treturn 0;",
            "}"
        ]
    },
    "using LL": {
        "prefix": "using LL = long long",
        "body": [
            "using LL = long long;",
            "$0"
        ]
    },
    "using ULL": {
        "prefix": "using ULL = unsigned long long",
        "body": [
            "using ULL = unsigned long long;",
            "$0"
        ]
    },
    "using PII": {
        "prefix": "using PII = pair<int, int>",
        "body": [
            "using PII = pair<int, int>;",
            "$0"
        ]
    },
    "using PDD": {
        "prefix": "using PDD = pair<double, double>",
        "body": [
            "using PDD = pair<int, int>;",
            "$0"
        ]
    },
    "常数 N": {
        "prefix": "const int N = ",
        "body": [
            "const int N = $0;"
        ]
    },
    "eps": {
        "prefix": "const double eps = 1e-8;",
        "body": [
            "const double eps = 1e-8;",
            "$0"
        ]
    },
    "pi": {
        "prefix": "const double PI = acos(-1);",
        "body": [
            "const double PI = acos(-1);",
            "$0"
        ]
    },
    "重复 N 次": {
        "prefix": "while",
        "body": [
            "while (${1|n,m,T|}--){",
            "\t$0",
            "}"
        ]
    },
    "for 0 ... N-1": {
        "prefix": "for (",
        "body": [
            "for (${1|i,j,k|} = 0; $1 < n; ++$1) {",
            "\t$0",
            "}"
        ]
    },
    "for 1 ... N": {
        "prefix": "for (",
        "body": [
            "for (${1|i,j,k|} = 1; $1 <= n; ++$1) {",
            "\t$0",
            "}"
        ]
    },
    "cin": {
        "prefix": "cin >> ",
        "body": [
            "cin >> $0"
        ]
    },
    "cout": {
        "prefix": "cout << ",
        "body": [
            "cout << $0"
        ]
    },
    "scanf": {
        "prefix": "scanf(",
        "body": [
            "scanf($0);"
        ]
    },
    "printf": {
        "prefix": "printf(",
        "body": [
            "printf($0);"
        ]
    },
    "memset": {
        "prefix": "memset(",
        "body": [
            "memset(${1|h|}, ${2|0,-1,0x3f|}, sizeof ${3|h|});",
            "$0"
        ]
    },
    "add edge": {
        "prefix": "add(",
        "body": [
            "add(a, b);",
            "$0"
        ]
    },
    "add edge weight": {
        "prefix": "add(",
        "body": [
            "add(a, b, c);",
            "$0"
        ]
    },
    "dlx add edge": {
        "prefix": "add(",
        "body": [
            "add(a, b, c, d);",
            "$0"
        ]
    },
    "int h[N]...邻接表不带权": {
        "prefix": "int adj",
        "body": [
            "int h[N], e[M], ne[M], idx;",
            ""
        ]
    },
    "int h[N]...邻接表spfa": {
        "prefix": "int adj",
        "body": [
            "int h[N], e[M], w[M], ne[M], idx;",
            "int q[N], dist[N];",
            "bool st[N];",
            ""
        ]
    },
    "int h[N]...邻接表dijkstra": {
        "prefix": "int adj",
        "body": [
            "int h[N], e[M], w[M], ne[M], idx;",
            "int dist[N];",
            "bool st[N];",
            ""
        ]
    },
    "int h[N]...邻接表最大流": {
        "prefix": "int adj",
        "body": [
            "int h[N], e[M], f[M], ne[M], idx;",
            "int q[N], d[N], pre[N];",
            "bool st[N];",
            ""
        ]
    },
    "int h[N]...邻接表费用流": {
        "prefix": "int adj",
        "body": [
            "int h[N], e[M], f[M], w[M], ne[M], idx;",
            "int q[N], d[N], pre[N], incf[N];",
            "bool st[N];",
            ""
        ]
    },
    "int h[N]...邻接表tarjan-scc": {
        "prefix": "int adj",
        "body": [
            "int h[N], e[M], ne[M], idx;",
            "int dfn[N], low[N];",
            "// 时间戳",
            "int timestamp;",
            "int stk[N], top;",
            "bool in_stk[N];",
            "int id[N]",
            "// 每个点所属分量编号",
            "int scc_cnt;",
            ""
        ]
    },
    "int h[N]...邻接表tarjan-e-dcc": {
        "prefix": "int adj",
        "body": [
            "int h[N], e[M], ne[M], idx;",
            "int dfn[N], low[N]",
            "// 时间戳",
            "int timestamp;",
            "int stk[N], top;",
            "int id[N]",
            "// 每个点所属分量编号",
            "int dcc_cnt;",
            "bool is_bridge[M];",
            ""
        ]
    },
    "int h[N]...邻接表tarjan-v-dcc": {
        "prefix": "int adj",
        "body": [
            "int h[N], e[M], ne[M], idx;",
            "int dfn[N], low[N]",
            "// 时间戳",
            "int timestamp;",
            "int stk[N], top;",
            "int dcc_cnt;",
            "// 每个分量有哪些点",
            "vector<int> dcc[N];",
            "// 是否为割点",
            "bool cut[N];",
            "int root;",
            ""
        ]
    },
    "gcd": {
        "prefix": "gcd",
        "body": [
            "${1|int,LL|} gcd($1 a, $1 b) {",
            "\t// 欧几里得算法",
            "\treturn b ? gcd(b, a % b) : a;",
            "}",
            "$0"
        ]
    },
    "exgcd": {
        "prefix": "exgcd",
        "body": [
            "int exgcd(int a, int b, int &x, int &y)  // 扩展欧几里得算法, 求x, y，使得ax + by = gcd(a, b)\n{\n    if (!b)\n    {\n        x = 1; y = 0;\n        return a;\n    }\n    int d = exgcd(b, a % b, y, x);\n    y -= (a / b) * x;\n    return d;\n}\n"
        ]
    },
    "高精度 加法": {
        "prefix": "high add",
        "body": [
            "vector<int> add(vector<int> &A, vector<int> &B) {",
            "\t// C = A + B, A >= 0, B >= 0",
            "\tif (A.size() < B.size()) {",
            "\t\treturn add(B, A);",
            "\t}",
            "",
            "\tvector<int> C;",
            "\tint t = 0;",
            "\tfor (int i = 0; i < A.size(); ++i) {",
            "\t\tt += A[i];",
            "\t\tif (i < B.size()) {",
            "\t\t\tt += B[i];",
            "\t\t}",
            "\t\tC.push_back(t % 10);",
            "\t\tt /= 10;",
            "\t}",
            "",
            "\tif (t) {",
            "\t\tC.push_back(t);",
            "\t}",
            "\treturn C;",
            "}",
            "$0"
        ]
    },
    "高精度 减法": {
        "prefix": "high sub",
        "body": [
            "vector<int> sub(vector<int> &A, vector<int> &B) {",
            "\t// C = A - B, 满足A >= B, A >= 0, B >= 0",
            "\tvector<int> C;",
            "\tfor (int i = 0, t = 0; i < A.size(); ++i) {",
            "\t\tt = A[i] - t;",
            "\t\tif (i < B.size()) {",
            "\t\t\tt -= B[i];",
            "\t\t}",
            "\t\tC.push_back((t + 10) % 10);",
            "\t\tif (t < 0) {",
            "\t\t\tt = 1;",
            "\t\t} else {",
            "\t\t\tt = 0;",
            "\t\t}",
            "\t}",
            "",
            "\twhile (C.size() > 1 && C.back() == 0) {",
            "\t\tC.pop_back();",
            "\t}",
            "\treturn C;",
            "}",
            "$0"
        ]
    },
    "高精度 乘低精度": {
        "prefix": "high mul",
        "body": [
            "vector<int> mul(vector<int> &A, int b) {",
            "\t// C = A * b, A >= 0, b >= 0",
            "\tvector<int> C;",
            "",
            "\tint t = 0;",
            "\tfor (int i = 0; i < A.size() || t; ++i) {",
            "\t\tif (i < A.size()) {",
            "\t\t\tt += A[i] * b;",
            "\t\t}",
            "\t\tC.push_back(t % 10);",
            "\t\tt /= 10;",
            "\t}",
            "",
            "\twhile (C.size() > 1 && C.back() == 0) {",
            "\t\tC.pop_back();",
            "\t}",
            "",
            "\treturn C;",
            "}",
            "$0"
        ]
    },
    "高精度 除以低精度": {
        "prefix": "high div",
        "body": [
            "vector<int> div(vector<int> &A, int b, int &r) {",
            "\t// A / b = C ... r, A >= 0, b > 0",
            "\tvector<int> C;",
            "\tr = 0;",
            "\tfor (int i = A.size() - 1; i >= 0; --i) {",
            "\t\tr = r * 10 + A[i];",
            "\t\tC.push_back(r / b);",
            "\t\tr %= b;",
            "\t}",
            "\treverse(C.begin(), C.end());",
            "\twhile (C.size() > 1 && C.back() == 0) {",
            "\t\tC.pop_back();",
            "\t}",
            "\treturn C;",
            "}",
            "$0"
        ]
    },
    "快速幂 求 a^k mod p": {
        "prefix": "kuaisumi bin pow",
        "body": [
            "int bin_pow(int a, int k, int p) {",
            "\t// 求a^k mod p",
            "\tint res = 1 % p;",
            "\twhile (k) {",
            "\t\tif (k & 1) res = (LL)res * a % p;",
            "\t\ta = (LL)a * a % p;",
            "\t\tk >>= 1;",
            "\t}",
            "\treturn res;",
            "}",
            "$0"
        ]
    },
    "lucas": {
        "prefix": "lucas",
        "body": [
            "int bin_pow(int a, int k, int p) {",
            "\t// 快速幂",
            "\tint res = 1 % p;",
            "\twhile (k) {",
            "\t\tif (k & 1) {",
            "\t\t\tres = (LL)res * a % p;",
            "\t\t}",
            "\t\ta = (LL)a * a % p;",
            "\t\tk >>= 1;",
            "\t}",
            "\treturn res;",
            "}",
            "",
            "int C(int a, int b, int p) {",
            "\t// 通过定理求组合数C(a, b)",
            "\tif (a < b) {",
            "\t\treturn 0;",
            "\t}",
            "",
            "\t// x是分子，y是分母",
            "\tLL x = 1, y = 1;",
            "\tfor (int i = a, j = 1; j <= b; --i, ++j) {",
            "\t\tx = (LL)x * i % p;",
            "\t\ty = (LL)y * j % p;",
            "\t}",
            "",
            "\treturn x * (LL)bin_pow(y, p - 2, p) % p;",
            "}",
            "",
            "int lucas(LL a, LL b, int p) {",
            "\tif (a < p && b < p) {",
            "\t\treturn C(a, b, p);",
            "\t}",
            "\treturn (LL)C(a % p, b % p, p) * lucas(a / p, b / p, p) % p;",
            "}",
            "$0"
        ]
    },
    "判定质数": {
        "prefix": "bool is_prime(",
        "body": [
            "bool is_prime(int x) {",
            "\t// 判定质数",
            "\tif (x < 2) {",
            "\t\treturn false;",
            "\t}",
            "\tfor (int i = 2; i <= x / i; ++i)",
            "\t\tif (x % i == 0) {",
            "\t\t\treturn false;",
            "\t\t}",
            "\treturn true;",
            "}",
            "$0"
        ]
    },
    "线性筛质数": {
        "prefix": "xianxingshai get_primes",
        "body": [
            "void get_primes(int n) {",
            "\t// 线性筛质数",
            "\tfor (int i = 2; i <= n; ++i) {",
            "\t\tif (!st[i]) {",
            "\t\t\tprimes[cnt++] = i;",
            "\t\t}",
            "\t\tfor (int j = 0; primes[j] <= n / i; ++j) {",
            "\t\t\tst[primes[j] * i] = true;",
            "\t\t\tif (i % primes[j] == 0) {",
            "\t\t\t\tbreak;",
            "\t\t\t}",
            "\t\t}",
            "\t}",
            "}",
            "$0"
        ]
    },
    "欧拉函数": {
        "prefix": "euler",
        "body": [
            "int phi(int x) {",
            "\t// 欧拉函数",
            "\tint res = x;",
            "\tfor (int i = 2; i <= x / i; ++i)",
            "\t\tif (x % i == 0) {",
            "\t\t\tres = res / i * (i - 1);",
            "\t\t\twhile (x % i == 0) {",
            "\t\t\t\tx /= i;",
            "\t\t\t}",
            "\t\t}",
            "\tif (x > 1) {",
            "\t\tres = res / x * (x - 1);",
            "\t}",
            "",
            "\treturn res;",
            "}",
            "$0"
        ]
    },
    "线性筛欧拉函数": {
        "prefix": "xianxingshai get_eulers",
        "body": [
            "void get_eulers(int n) {",
            "\t// 线性筛法求 1~n 的欧拉函数",
            "\teuler[1] = 1;",
            "\tfor (int i = 2; i <= n; ++i) {",
            "\t\tif (!st[i]) {",
            "\t\t\tprimes[cnt++] = i;",
            "\t\t\teuler[i] = i - 1;",
            "\t\t}",
            "\t\tfor (int j = 0; primes[j] <= n / i; ++j) {",
            "\t\t\tint t = primes[j] * i;",
            "\t\t\tst[t] = true;",
            "\t\t\tif (i % primes[j] == 0) {",
            "\t\t\t\teuler[t] = euler[i] * primes[j];",
            "\t\t\t\tbreak;",
            "\t\t\t}",
            "\t\t\teuler[t] = euler[i] * (primes[j] - 1);",
            "\t\t}",
            "\t}",
            "}",
            "$0"
        ]
    },
    "并查集": {
        "prefix": "int find(",
        "body": [
            "int find(int x) {",
            "\t// 并查集",
            "\tif (p[x] != x) {",
            "\t\tp[x] = find(p[x]);",
            "\t}",
            "\treturn p[x];",
            "}",
            "$0"
        ]
    },
    "字符串哈希": {
        "prefix": "string hash",
        "body": [
            "ULL get(int l, int r) {",
            "\t// 计算子串 str[l ~ r] 的哈希值",
            "\treturn h[r] - h[l - 1] * p[r - l + 1];",
            "}",
            "$0"
        ]
    },
    "lowbit": {
        "prefix": "lowbit",
        "body": [
            "int lowbit(int x) { return x & -x; }",
            "$0"
        ]
    },
    "树状数组": {
        "prefix": [
            "binary indexed tree",
            "shuzhuangshuzu"
        ],
        "body": [
            "int lowbit(int x) { return x & -x; }",
            "",
            "void update(int x, int c) {",
            "\t// 位置x加c",
            "\tfor (int i = x; i <= n; i += lowbit(i)) {",
            "\t\ttr[i] += c;",
            "\t}",
            "}",
            "",
            "int query(int x) {",
            "\t// 返回前x个数的和",
            "\tint res = 0;",
            "\tfor (int i = x; i; i -= lowbit(i)) {",
            "\t\tres += tr[i];",
            "\t}",
            "\treturn res;",
            "}",
            "$0"
        ]
    },
    "merge sort": {
        "prefix": "merge sort",
        "body": [
            "void merge_sort(int q[], int l, int r) {",
            "\t// 归并排序",
            "\tif (l >= r) {",
            "\t\treturn;",
            "\t}",
            "",
            "\tint mid = l + r >> 1;",
            "\tmerge_sort(q, l, mid);",
            "\tmerge_sort(q, mid + 1, r);",
            "",
            "\tint k = 0, i = l, j = mid + 1;",
            "\twhile (i <= mid && j <= r)",
            "\t\tif (q[i] <= q[j])",
            "\t\t\ttmp[k++] = q[i++];",
            "\t\telse",
            "\t\t\ttmp[k++] = q[j++];",
            "",
            "\twhile (i <= mid) {",
            "\t\ttmp[k++] = q[i++];",
            "\t}",
            "\twhile (j <= r) {",
            "\t\ttmp[k++] = q[j++];",
            "\t}",
            "",
            "\tfor (i = l, j = 0; i <= r; ++i, ++j) {",
            "\t\tq[i] = tmp[j];",
            "\t}",
            "}",
            "$0"
        ]
    },
    "manacher": {
        "prefix": "manacher",
        "body": [
            "void init() {",
            "\t// a[]为原串，b[]为插入'#'后的新串",
            "\tint k = 0;",
            "\tb[k++] = '$';",
            "\tb[k++] = '#';",
            "\tfor (int i = 0; i < n; ++i) {",
            "\t\tb[k++] = a[i];",
            "\t\tb[k++] = '#';",
            "\t}",
            "\tb[k++] = '^';",
            "\tn = k;",
            "}",
            "",
            "void manacher() {",
            "\t// 马拉车算法，b[]为插入'#'后的新串",
            "\tint mr = 0, mid = 0;",
            "\tfor (int i = 1; i < n; ++i) {",
            "\t\tif (i < mr) {",
            "\t\t\tp[i] = min(p[mid * 2 - i], mr - i);",
            "\t\t} else {",
            "\t\t\tp[i] = 1;",
            "\t\t}",
            "\t\twhile (b[i - p[i]] == b[i + p[i]]) {",
            "\t\t\t++p[i];",
            "\t\t}",
            "\t\tif (i + p[i] > mr) {",
            "\t\t\tmr = i + p[i];",
            "\t\t\tmid = i;",
            "\t\t}",
            "\t}",
            "}",
            "$0"
        ]
    },
    "DLX 重复覆盖": {
        "prefix": "dlx repeat",
        "body": [
            "int l[N], r[N], u[N], d[N], col[N], row[N], s[N], idx;",
            "// 记录选择了哪些行",
            "int ans[N], top;",
            "// N为节点数，M为列数",
            "bool st[M];",
            "",
            "void init() {",
            "\t// 初始化十字链表",
            "\tfor (int i = 0; i <= m; ++i) {",
            "\t\tl[i] = i - 1, r[i] = i + 1;",
            "\t\tu[i] = d[i] = i;",
            "\t\ts[i] = 0, col[i] = i;",
            "\t}",
            "\tl[0] = m, r[m] = 0;",
            "\tidx = m + 1;",
            "}",
            "",
            "void add(int& hh, int& tt, int x, int y) {",
            "\t// 在十字链表中插入节点",
            "\trow[idx] = x, col[idx] = y, ++s[y];",
            "\tu[idx] = y, d[idx] = d[y], u[d[y]] = idx, d[y] = idx;",
            "\tr[hh] = l[tt] = idx, r[idx] = tt, l[idx] = hh;",
            "\ttt = idx++;",
            "}",
            "",
            "int h() {",
            "\t// IDA*的启发函数",
            "\tint res = 0;",
            "\tmemset(st, 0, sizeof st);",
            "\tfor (int i = r[0]; i; i = r[i]) {",
            "\t\tif (st[col[i]]) {",
            "\t\t\tcontinue;",
            "\t\t}",
            "\t\t++res;",
            "\t\tst[col[i]] = true;",
            "\t\tfor (int j = d[i]; j != i; j = d[j]) {",
            "\t\t\tfor (int k = r[j]; k != j; k = r[k]) {",
            "\t\t\t\tst[col[k]] = true;",
            "\t\t\t}",
            "\t\t}",
            "\t}",
            "\treturn res;",
            "}",
            "",
            "void remove(int p) {",
            "\tfor (int i = d[p]; i != p; i = d[i]) {",
            "\t\tr[l[i]] = r[i];",
            "\t\tl[r[i]] = l[i];",
            "\t}",
            "}",
            "",
            "void resume(int p) {",
            "\tfor (int i = u[p]; i != p; i = u[i]) {",
            "\t\tr[l[i]] = i;",
            "\t\tl[r[i]] = i;",
            "\t}",
            "}",
            "",
            "bool dfs(int k) {",
            "\tif (k + h() > top) {",
            "\t\treturn false;",
            "\t}",
            "\tif (!r[0]) {",
            "\t\ttop = k;",
            "\t\treturn true;",
            "\t}",
            "\tint p = r[0];",
            "\tfor (int i = r[0]; i; i = r[i]) {",
            "\t\tif (s[i] < s[p]) {",
            "\t\t\tp = i;",
            "\t\t}",
            "\t}",
            "\tfor (int i = d[p]; i != p; i = d[i]) {",
            "\t\tans[k] = row[i];",
            "\t\tremove(i);",
            "\t\tfor (int j = r[i]; j != i; j = r[j]) {",
            "\t\t\tremove(j);",
            "\t\t}",
            "\t\tif (dfs(k + 1)) {",
            "\t\t\treturn true;",
            "\t\t}",
            "\t\tfor (int j = l[i]; j != i; j = l[j]) {",
            "\t\t\tresume(j);",
            "\t\t}",
            "\t\tresume(i);",
            "\t}",
            "\treturn false;",
            "}",
            "$0"
        ]
    },
    "DLX 精确覆盖": {
        "prefix": "dlx exact cover",
        "body": [
            "int l[N], r[N], u[N], d[N], col[N], row[N], s[N], idx;",
            "// 记录选择了哪些行",
            "int ans[N], top;",
            "",
            "void init() {",
            "\t// 初始化十字链表",
            "\tfor (int i = 0; i <= m; ++i) {",
            "\t\tl[i] = i - 1, r[i] = i + 1;",
            "\t\tu[i] = d[i] = i;",
            "\t}",
            "\tl[0] = m, r[m] = 0;",
            "\tidx = m + 1;",
            "}",
            "",
            "void add(int& hh, int& tt, int x, int y) {",
            "\t// 在十字链表中添加节点",
            "\trow[idx] = x, col[idx] = y, ++s[y];",
            "\tu[idx] = y, d[idx] = d[y], u[d[y]] = idx, d[y] = idx;",
            "\tr[hh] = l[tt] = idx, r[idx] = tt, l[idx] = hh;",
            "\ttt = idx++;",
            "}",
            "",
            "void remove(int p) {",
            "\tr[l[p]] = r[p], l[r[p]] = l[p];",
            "\tfor (int i = d[p]; i != p; i = d[i]) {",
            "\t\tfor (int j = r[i]; j != i; j = r[j]) {",
            "\t\t\t--s[col[j]];",
            "\t\t\td[u[j]] = d[j], u[d[j]] = u[j];",
            "\t\t}",
            "\t}",
            "}",
            "",
            "void resume(int p) {",
            "\tfor (int i = d[p]; i != p; i = d[i])",
            "\t\tfor (int j = r[i]; j != i; j = r[j]) {",
            "\t\t\t++s[col[j]];",
            "\t\t\td[u[j]] = j, u[d[j]] = j;",
            "\t\t}",
            "\tr[l[p]] = p, l[r[p]] = p;",
            "}",
            "",
            "bool dfs() {",
            "\tif (!r[0]) {",
            "\t\treturn true;",
            "\t}",
            "\tint p = r[0];",
            "\tfor (int i = r[0]; i; i = r[i])",
            "\t\tif (s[i] < s[p]) {",
            "\t\t\tp = i;",
            "\t\t}",
            "\tif (!s[p]) {",
            "\t\treturn false;",
            "\t}",
            "\tremove(p);",
            "\tfor (int i = d[p]; i != p; i = d[i]) {",
            "\t\tans[++top] = row[i];",
            "\t\tfor (int j = r[i]; j != i; j = r[j]) {",
            "\t\t\tremove(col[j]);",
            "\t\t}",
            "\t\tif (dfs()) {",
            "\t\t\treturn true;",
            "\t\t}",
            "\t\tfor (int j = r[i]; j != i; j = r[j]) {",
            "\t\t\tresume(col[j]);",
            "\t\t}",
            "\t\t--top;",
            "\t}",
            "\tresume(p);",
            "\treturn false;",
            "}",
            "$0"
        ]
    },
    "splay 动态树": {
        "prefix": "splay dongtaishu",
        "body": [
            "struct Node {",
            "\tint s[2], p, v;",
            "\tint rev;",
            "\t// TODO: 定义需要维护的信息和懒标记",
            "} tr[N];",
            "",
            "// 栈",
            "int stk[N];",
            "",
            "void pushrev(int x) {",
            "\tswap(tr[x].s[0], tr[x].s[1]);",
            "\ttr[x].rev ^= 1;",
            "}",
            "",
            "void pushup(int x) {",
            "\t// TODO: 利用子节点信息来维护当前节点的信息",
            "\t$0",
            "}",
            "",
            "void pushdown(int x) {",
            "\tif (tr[x].rev) {",
            "\t\tpushrev(tr[x].s[0]);",
            "\t\tpushrev(tr[x].s[1]);",
            "\t\ttr[x].rev = 0;",
            "\t}",
            "\t// TODO: 将当前节点的懒标记下传",
            "}",
            "",
            "bool isroot(int x) {",
            "\t// 判断x是否为原树的根节点",
            "\treturn tr[tr[x].p].s[0] != x && tr[tr[x].p].s[1] != x;",
            "}",
            "",
            "void rotate(int x) {",
            "\t// splay的旋转操作",
            "\tint y = tr[x].p;",
            "\tint z = tr[y].p;",
            "\tint k = tr[y].s[1] == x;",
            "\tif (!isroot(y)) {",
            "\t\ttr[z].s[tr[z].s[1] == y] = x;",
            "\t}",
            "\ttr[x].p = z;",
            "\ttr[y].s[k] = tr[x].s[k ^ 1];",
            "\ttr[tr[x].s[k ^ 1]].p = y;",
            "\ttr[x].s[k ^ 1] = y;",
            "\ttr[y].p = x;",
            "\tpushup(y);",
            "\tpushup(x);",
            "}",
            "",
            "void splay(int x)\t// splay操作",
            "{",
            "\tint top = 0, r = x;",
            "\tstk[++top] = r;",
            "\twhile (!isroot(r)) {",
            "\t\tstk[++top] = r = tr[r].p;",
            "\t}",
            "\twhile (top) {",
            "\t\tpushdown(stk[top--]);",
            "\t}",
            "\twhile (!isroot(x)) {",
            "\t\tint y = tr[x].p;",
            "\t\tint z = tr[y].p;",
            "\t\tif (!isroot(y)) {",
            "\t\t\tif ((tr[y].s[1] == x) ^ (tr[z].s[1] == y)) {",
            "\t\t\t\trotate(x);",
            "\t\t\t} else {",
            "\t\t\t\trotate(y);",
            "\t\t\t}",
            "\t\t}",
            "\t\trotate(x);",
            "\t}",
            "}",
            "",
            "void access(int x) {",
            "\t// 建立一条从根到x的路径，同时将x变成splay的根节点",
            "\tint z = x;",
            "\tfor (int y = 0; x; y = x, x = tr[x].p) {",
            "\t\tsplay(x);",
            "\t\ttr[x].s[1] = y, pushup(x);",
            "\t}",
            "\tsplay(z);",
            "}",
            "",
            "void makeroot(int x) {",
            "\t// 将x变成原树的根节点",
            "\taccess(x);",
            "\tpushrev(x);",
            "}",
            "",
            "int findroot(int x) {",
            "\t// 找到x所在原树的根节点, 再将原树的根节点旋转到splay的根节点",
            "\taccess(x);",
            "\twhile (tr[x].s[0]) {",
            "\t\tpushdown(x);",
            "\t\tx = tr[x].s[0];",
            "\t}",
            "\tsplay(x);",
            "\treturn x;",
            "}",
            "",
            "void split(int x, int y) {",
            "\t// 给x和y之间的路径建立一个splay，其根节点是y",
            "\tmakeroot(x);",
            "\taccess(y);",
            "}",
            "",
            "void link(int x, int y) {",
            "\t// 如果x和y不连通，则加入一条x和y之间的边",
            "\tmakeroot(x);",
            "\tif (findroot(y) != x) {",
            "\t\ttr[x].p = y;",
            "\t}",
            "}",
            "",
            "void cut(int x, int y) {",
            "\t// 如果x和y之间存在边，则删除该边",
            "\tmakeroot(x);",
            "\tif (findroot(y) == x && tr[y].p == x && !tr[y].s[0]) {",
            "\t\ttr[x].s[1] = tr[y].p = 0;",
            "\t\tpushup(x);",
            "\t}",
            "}"
        ]
    },
    "splay": {
        "prefix": "splay",
        "body": [
            "struct Node {",
            "\tint s[2], p, v;",
            "\tint size;",
            "",
            "\tvoid init(int _v, int _p) {",
            "\t\tv = _v;",
            "\t\tp = _p;",
            "\t\tsize = 1;",
            "\t}",
            "} tr[N];",
            "",
            "int root, idx;",
            "",
            "void pushup(int x) {",
            "\t// TODO: 利用子节点信息维护当前节点信息",
            "\t$0",
            "}",
            "",
            "void pushdown(int x) {",
            "\t// TODO: 将懒标记下传",
            "}",
            "",
            "void rotate(int x) {",
            "\t// 旋转",
            "\tint y = tr[x].p;",
            "\tint z = tr[y].p;",
            "\tint k = tr[y].s[1] == x;",
            "\ttr[z].s[tr[z].s[1] == y] = x;",
            "\ttr[x].p = z;",
            "\ttr[y].s[k] = tr[x].s[k ^ 1];",
            "\ttr[tr[x].s[k ^ 1]].p = y;",
            "\ttr[x].s[k ^ 1] = y;",
            "\ttr[y].p = x;",
            "\tpushup(y);",
            "\tpushup(x);",
            "}",
            "",
            "void splay(int x, int k) {",
            "\t// splay操作",
            "\twhile (tr[x].p != k) {",
            "\t\tint y = tr[x].p;",
            "\t\tint z = tr[y].p;",
            "\t\tif (z != k) {",
            "\t\t\tif ((tr[y].s[1] == x) ^ (tr[z].s[1] == y)) {",
            "\t\t\t\trotate(x);",
            "\t\t\t} else {",
            "\t\t\t\trotate(y);",
            "\t\t\t}",
            "\t\t}",
            "\t\trotate(x);",
            "\t}",
            "\tif (!k) {",
            "\t\troot = x;",
            "\t}",
            "}"
        ]
    },
    "线段树": {
        "prefix": "segment tree",
        "body": [
            "struct Node {",
            "\tint l, r;",
            "\t// TODO: 需要维护的信息和懒标记",
            "} tr[N * 4];",
            "",
            "void pushup(int u) {",
            "\t// TODO: 利用左右儿子信息维护当前节点的信息",
            "\t$0",
            "}",
            "",
            "void pushdown(int u) {",
            "\t// TODO: 将懒标记下传",
            "}",
            "",
            "void build(int u, int l, int r) {",
            "\tif (l == r) {",
            "\t\ttr[u] = {l, r};",
            "\t\treturn;",
            "\t}",
            "\ttr[u] = {l, r};",
            "\tint mid = l + r >> 1;",
            "\tbuild(u << 1, l, mid);",
            "\tbuild(u << 1 | 1, mid + 1, r);",
            "\tpushup(u);",
            "}",
            "",
            "void update(int u, int l, int r, int d) {",
            "\tif (tr[u].l >= l && tr[u].r <= r) {",
            "\t\t// TODO: 修改区间",
            "\t\treturn;",
            "\t}",
            "\tpushdown(u);",
            "\tint mid = tr[u].l + tr[u].r >> 1;",
            "\tif (l <= mid) {",
            "\t\tupdate(u << 1, l, r, d);",
            "\t}",
            "\tif (r > mid) {",
            "\t\tupdate(u << 1 | 1, l, r, d);",
            "\t}",
            "\tpushup(u);",
            "}",
            "",
            "int query(int u, int l, int r) {",
            "\tif (tr[u].l >= l && tr[u].r <= r) {",
            "\t\t// TODO 需要补充返回值",
            "\t\treturn;",
            "\t}",
            "",
            "\tpushdown(u);",
            "\tint mid = tr[u].l + tr[u].r >> 1;",
            "\tint res = 0;",
            "\tif (l <= mid) {",
            "\t\tres = query(u << 1, l, r);",
            "\t}",
            "\tif (r > mid) {",
            "\t\tres += query(u << 1 | 1, l, r);",
            "\t}",
            "\treturn res;",
            "}"
        ]
    },
    "AC自动机": {
        "prefix": "aho corasick ac auto",
        "body": [
            "void insert(char str[]) {",
            "\t// 将str插入Trie中",
            "\tint p = 0;",
            "\tfor (int i = 0; str[i]; ++i) {",
            "\t\tint u = str[i] - 'a';",
            "\t\tif (!tr[p][u]) {",
            "\t\t\ttr[p][u] = ++idx;",
            "\t\t}",
            "\t\tp = tr[p][u];",
            "\t}",
            "\t// 记录单词出现次数",
            "\t++cnt[p];",
            "}",
            "",
            "void build() {",
            "\t// 创建AC自动机",
            "\tint hh = 0, tt = -1;",
            "\tfor (int i = 0; i < 26; ++i)",
            "\t\tif (tr[0][i]) {",
            "\t\t\tq[++tt] = tr[0][i];",
            "\t\t}",
            "\twhile (hh <= tt) {",
            "\t\tint t = q[hh++];",
            "\t\tfor (int i = 0; i < 26; ++i) {",
            "\t\t\tint p = tr[t][i];",
            "\t\t\tif (!p) {",
            "\t\t\t\ttr[t][i] = tr[ne[t]][i];",
            "\t\t\t} else {",
            "\t\t\t\tne[p] = tr[ne[t]][i];",
            "\t\t\t\tcnt[p] += cnt[ne[p]];",
            "\t\t\t\tq[++tt] = p;",
            "\t\t\t}",
            "\t\t}",
            "\t}",
            "}",
            "$0"
        ]
    },
    "左偏树": {
        "prefix": "left tree",
        "body": [
            "int v[N], dist[N], l[N], r[N], idx;",
            "",
            "bool cmp(int x, int y) {",
            "\t// 比较两个节点的权值大小",
            "\tif (v[x] != v[y]) {",
            "\t\treturn v[x] < v[y];",
            "\t}",
            "\treturn x < y;",
            "}",
            "",
            "int merge(int x, int y) {",
            "\t// 合并两棵左偏树",
            "\tif (!x || !y) {",
            "\t\treturn x + y;",
            "\t}",
            "\tif (cmp(y, x)) {",
            "\t\tswap(x, y);",
            "\t}",
            "\tr[x] = merge(r[x], y);",
            "\tif (dist[r[x]] > dist[l[x]]) {",
            "\t\tswap(l[x], r[x]);",
            "\t}",
            "\tdist[x] = dist[r[x]] + 1;",
            "\treturn x;",
            "}",
            "$0"
        ]
    },
    "后缀数组": {
        "prefix": "sa",
        "body": [
            "// 存储原字符串",
            "char s[N];",
            "int sa[N], rk[N], x[N], y[N], height[N], c[N];",
            "",
            "void get_sa() {",
            "\t// 创建后缀数组",
            "\tfor (int i = 1; i <= n; ++i) {",
            "\t\tc[x[i] = s[i]]++;",
            "\t}",
            "\tfor (int i = 2; i <= m; ++i) {",
            "\t\tc[i] += c[i - 1];",
            "\t}",
            "\tfor (int i = n; i; --i) {",
            "\t\tsa[c[x[i]]--] = i;",
            "\t}",
            "\tfor (int k = 1; k <= n; k <<= 1) {",
            "\t\tint num = 0;",
            "\t\tfor (int i = n - k + 1; i <= n; ++i) {",
            "\t\t\ty[++num] = i;",
            "\t\t}",
            "\t\tfor (int i = 1; i <= n; ++i) {",
            "\t\t\tif (sa[i] > k) {",
            "\t\t\t\ty[++num] = sa[i] - k;",
            "\t\t\t}",
            "\t\t}",
            "\t\tfor (int i = 1; i <= m; ++i) {",
            "\t\t\tc[i] = 0;",
            "\t\t}",
            "\t\tfor (int i = 1; i <= n; ++i) {",
            "\t\t\t++c[x[i]];",
            "\t\t}",
            "\t\tfor (int i = 2; i <= m; ++i) {",
            "\t\t\tc[i] += c[i - 1];",
            "\t\t}",
            "\t\tfor (int i = n; i; --i) {",
            "\t\t\tsa[c[x[y[i]]]--] = y[i];",
            "\t\t\ty[i] = 0;",
            "\t\t}",
            "\t\tswap(x, y);",
            "\t\tx[sa[1]] = 1;",
            "\t\tnum = 1;",
            "\t\tfor (int i = 2; i <= n; ++i) {",
            "\t\t\tif (y[sa[i]] == y[sa[i - 1]] && y[sa[i] + k] == y[sa[i - 1] + k]) {",
            "\t\t\t\tx[sa[i]] = num",
            "\t\t\t} else {",
            "\t\t\t\tx[sa[i]] = ++num;",
            "\t\t\t}",
            "\t\t}",
            "\t\tif (num == n) {",
            "\t\t\tbreak;",
            "\t\t}",
            "\t\tm = num;",
            "\t}",
            "}",
            "",
            "void get_height() {",
            "\t// 预处理height[]数组",
            "\tint k = 0;",
            "\tfor (int i = 1; i <= n; ++i) {",
            "\t\trk[sa[i]] = i;",
            "\t}",
            "\tfor (int i = 1; i <= n; ++i) {",
            "\t\tif (rk[i] == 1) {",
            "\t\t\tcontinue;",
            "\t\t}",
            "\t\tif (k) {",
            "\t\t\t--k;",
            "\t\t}",
            "\t\tint j = sa[rk[i] - 1];",
            "\t\twhile (i + k <= n && j + k <= n && s[i + k] == s[j + k]) {",
            "\t\t\t++k;",
            "\t\t}",
            "\t\theight[rk[i]] = k;",
            "\t}",
            "}",
            "$0"
        ]
    },
    "后缀自动机": {
        "prefix": "post auto",
        "body": [
            "int tot = 1, last = 1;",
            "",
            "struct Node {",
            "\tint len, fa;",
            "\tint ch[26];",
            "} node[N];",
            "",
            "void extend(char c) {",
            "\tint p = last, np = last = ++tot;",
            "\tnode[np].len = node[p].len + 1;",
            "\tfor (; p && !node[p].ch[c]; p = node[p].fa) {",
            "\t\tnode[p].ch[c] = np;",
            "\t}",
            "\tif (!p) {",
            "\t\tnode[np].fa = 1;",
            "\t\treturn;",
            "\t}",
            "\tint q = node[p].ch[c];",
            "\tif (node[q].len == node[p].len + 1) {",
            "\t\tnode[np].fa = q;",
            "\t\treturn;",
            "\t}",
            "\tint nq = ++tot;",
            "\tnode[nq] = node[q];",
            "\tnode[nq].len = node[p].len + 1;",
            "\tnode[q].fa = node[np].fa = nq;",
            "\tfor (; p && node[p].ch[c] == q; p = node[p].fa) {",
            "\t\tnode[p].ch[c] = nq;",
            "\t}",
            "}",
            "$0"
        ]
    },
    "trie": {
        "prefix": "trie",
        "body": [
            "int son[N][26], cnt[N], idx;",
            "",
            "void insert(char *str) {",
            "\t// 插入字符串",
            "\tint p = 0;",
            "\tfor (int i = 0; str[i]; ++i) {",
            "\t\tint u = str[i] - 'a';",
            "\t\tif (!son[p][u]) {",
            "\t\t\tson[p][u] = ++idx;",
            "\t\t}",
            "\t\tp = son[p][u];",
            "\t}",
            "\t++cnt[p];",
            "}",
            "",
            "int query(char *str) {",
            "\t// 查询字符串出现次数",
            "\tint p = 0;",
            "\tfor (int i = 0; str[i]; ++i) {",
            "\t\tint u = str[i] - 'a';",
            "\t\tif (!son[p][u]) {",
            "\t\t\treturn 0;",
            "\t\t}",
            "\t\tp = son[p][u];",
            "\t}",
            "\treturn cnt[p];",
            "}",
            "$0"
        ]
    },
    "void toposort": {
        "prefix": "void toposort",
        "body": [
            "void toposort() {",
            "\tint hh = 0, tt = -1;",
            "",
            "\t// d[i] 存储点i的入度",
            "\tfor (int i = 1; i <= n; ++i)",
            "\t\tif (!d[i]) {",
            "\t\t\tq[++tt] = i;",
            "\t\t}",
            "",
            "\twhile (hh <= tt) {",
            "\t\tint t = q[hh++];",
            "",
            "\t\tfor (int i = h[t]; i != -1; i = ne[i]) {",
            "\t\t\tint j = e[i];",
            "\t\t\tif (--d[j] == 0) {",
            "\t\t\t\tq[++tt] = j;",
            "\t\t\t}",
            "\t\t}",
            "\t}",
            "}",
            "$0"
        ]
    },
    "bool toposort": {
        "prefix": "bool toposort",
        "body": [
            "bool toposort() {",
            "\tint hh = 0, tt = -1;",
            "",
            "\t// d[i] 存储点i的入度",
            "\tfor (int i = 1; i <= n; ++i)",
            "\t\tif (!d[i]) {",
            "\t\t\tq[++tt] = i;",
            "\t\t}",
            "",
            "\twhile (hh <= tt) {",
            "\t\tint t = q[hh++];",
            "",
            "\t\tfor (int i = h[t]; i != -1; i = ne[i]) {",
            "\t\t\tint j = e[i];",
            "\t\t\tif (--d[j] == 0) {",
            "\t\t\t\tq[++tt] = j;",
            "\t\t\t}",
            "\t\t}",
            "\t}",
            "",
            "\t// 如果所有点都入队了，说明存在拓扑序列；否则不存在拓扑序列。",
            "\treturn tt == n - 1;",
            "}",
            "$0"
        ]
    },
    "int dijkstra 最短路": {
        "prefix": "int dijkstra",
        "body": [
            "int dijkstra() {",
            "\t// 求1号点到n号点的最短路距离，如果从1号点无法走到n号点则返回-1",
            "\tmemset(dist, 0x3f, sizeof dist);",
            "\tdist[1] = 0;",
            "\tpriority_queue<PII, vector<PII>, greater<PII>> heap;",
            "\theap.push({0, 1});",
            "",
            "\twhile (heap.size()) {",
            "\t\tauto t = heap.top();",
            "\t\theap.pop();",
            "",
            "\t\tint v = t.second, distance = t.first;",
            "",
            "\t\tif (st[v]) {",
            "\t\t\tcontinue;",
            "\t\t}",
            "\t\tst[v] = true;",
            "",
            "\t\tfor (int i = h[v]; i != -1; i = ne[i]) {",
            "\t\t\tint j = e[i];",
            "\t\t\tif (dist[j] > dist[v] + w[i]) {",
            "\t\t\t\tdist[j] = dist[v] + w[i];",
            "\t\t\t\theap.push({dist[j], j});",
            "\t\t\t}",
            "\t\t}",
            "\t}",
            "",
            "\tif (dist[n] == 0x3f3f3f3f) {",
            "\t\treturn -1;",
            "\t}",
            "\treturn dist[n];",
            "}",
            "$0"
        ]
    },
    "void dijkstra 最短路": {
        "prefix": "void dijkstra",
        "body": [
            "void dijkstra() {",
            "\t// 求1号点到n号点的最短路距离",
            "\tmemset(dist, 0x3f, sizeof dist);",
            "\tdist[1] = 0;",
            "\tpriority_queue<PII, vector<PII>, greater<PII>> heap;",
            "\theap.push({0, 1});",
            "",
            "\twhile (heap.size()) {",
            "\t\tauto t = heap.top();",
            "\t\theap.pop();",
            "",
            "\t\tint v = t.second, distance = t.first;",
            "",
            "\t\tif (st[v]) {",
            "\t\t\tcontinue;",
            "\t\t}",
            "\t\tst[v] = true;",
            "",
            "\t\tfor (int i = h[v]; i != -1; i = ne[i]) {",
            "\t\t\tint j = e[i];",
            "\t\t\tif (dist[j] > dist[v] + w[i]) {",
            "\t\t\t\tdist[j] = dist[v] + w[i];",
            "\t\t\t\theap.push({dist[j], j});",
            "\t\t\t}",
            "\t\t}",
            "\t}",
            "}",
            "$0"
        ]
    },
    "int spfa 最短路": {
        "prefix": "int spfa",
        "body": [
            "int spfa() {",
            "\t// 求1号点到n号点的最短路距离，如果从1号点无法走到n号点则返回-1",
            "\tint hh = 0, tt = 0;",
            "\tmemset(dist, 0x3f, sizeof dist);",
            "\tdist[1] = 0;",
            "\tq[tt++] = 1;",
            "\tst[1] = true;",
            "",
            "\twhile (hh != tt) {",
            "\t\tint t = q[hh++];",
            "\t\tif (hh == N) {",
            "\t\t\thh = 0;",
            "\t\t}",
            "\t\tst[t] = false;",
            "",
            "\t\tfor (int i = h[t]; i != -1; i = ne[i]) {",
            "\t\t\tint j = e[i];",
            "\t\t\tif (dist[j] > dist[t] + w[i]) {",
            "\t\t\t\tdist[j] = dist[t] + w[i];",
            "\t\t\t\tif (!st[j]) {",
            "\t\t\t\t\t// 如果队列中已存在j，则不需要将j重复插入",
            "\t\t\t\t\tq[tt++] = j;",
            "\t\t\t\t\tif (tt == N) {",
            "\t\t\t\t\t\ttt = 0;",
            "\t\t\t\t\t}",
            "\t\t\t\t\tst[j] = true;",
            "\t\t\t\t}",
            "\t\t\t}",
            "\t\t}",
            "\t}",
            "",
            "\tif (dist[n] == 0x3f3f3f3f) {",
            "\t\treturn -1;",
            "\t}",
            "\treturn dist[n];",
            "}",
            "$0"
        ]
    },
    "void spfa 最短路": {
        "prefix": "void spfa",
        "body": [
            "void spfa() {",
            "\t// 求1号点到n号点的最短路距离",
            "\tint hh = 0, tt = 0;",
            "\tmemset(dist, 0x3f, sizeof dist);",
            "\tdist[1] = 0;",
            "\tq[tt++] = 1;",
            "\tst[1] = true;",
            "",
            "\twhile (hh != tt) {",
            "\t\tint t = q[hh++];",
            "\t\tif (hh == N) {",
            "\t\t\thh = 0;",
            "\t\t}",
            "\t\tst[t] = false;",
            "",
            "\t\tfor (int i = h[t]; i != -1; i = ne[i]) {",
            "\t\t\tint j = e[i];",
            "\t\t\tif (dist[j] > dist[t] + w[i]) {",
            "\t\t\t\tdist[j] = dist[t] + w[i];",
            "\t\t\t\tif (!st[j]) {",
            "\t\t\t\t\t// 如果队列中已存在j，则不需要将j重复插入",
            "\t\t\t\t\tq[tt++] = j;",
            "\t\t\t\t\tif (tt == N) {",
            "\t\t\t\t\t\ttt = 0;",
            "\t\t\t\t\t}",
            "\t\t\t\t\tst[j] = true;",
            "\t\t\t\t}",
            "\t\t\t}",
            "\t\t}",
            "\t}",
            "}",
            "$0"
        ]
    },
    "bool spfa 判断负环": {
        "prefix": "bool spfa negative",
        "body": [
            "bool spfa() {",
            "\t// 如果存在负环，则返回true，否则返回false。",
            "",
            "\t// 不需要初始化dist数组",
            "\t// 原理：如果某条最短路径上有n个点（除了自己），那么加上自己之后一共有n+1个点，",
            "\t// 由抽屉原理一定有两个点相同，所以存在环。",
            "",
            "\tint hh = 0, tt = 0;",
            "",
            "\tfor (int i = 1; i <= n; i++) {",
            "\t\tq[tt++] = i;",
            "\t\tst[i] = true;",
            "\t}",
            "",
            "\twhile (hh != tt) {",
            "\t\tint t = q[hh++];",
            "\t\tif (hh == N) {",
            "\t\t\thh = 0;",
            "\t\t}",
            "\t\tst[t] = false;",
            "",
            "\t\tfor (int i = h[t]; ~i; i = ne[i]) {",
            "\t\t\tint j = e[i];",
            "\t\t\tif (dist[j] > dist[t] + w[i]) {",
            "\t\t\t\tdist[j] = dist[t] + w[i];",
            "\t\t\t\tcnt[j] = cnt[t] + 1;",
            "\t\t\t\tif (cnt[j] >= n) {",
            "\t\t\t\t\treturn true;",
            "\t\t\t\t}",
            "\t\t\t\tif (!st[j]) {",
            "\t\t\t\t\tst[j] = true;",
            "\t\t\t\t\tq[tt++] = j;",
            "\t\t\t\t\tif (tt == N) {",
            "\t\t\t\t\t\ttt = 0;",
            "\t\t\t\t\t}",
            "\t\t\t\t}",
            "\t\t\t}",
            "\t\t}",
            "\t}",
            "",
            "\treturn false;",
            "}",
            "$0"
        ]
    },
    "void 费用流": {
        "prefix": "void cost flow",
        "body": [
            "bool spfa() {",
            "\t// 找距离最短的增广路",
            "\tint hh = 0, tt = 1;",
            "\tmemset(d, 0x3f, sizeof d);",
            "\tq[0] = S, d[S] = 0, incf[S] = INF;",
            "\twhile (hh != tt) {",
            "\t\tint t = q[hh++];",
            "\t\tif (hh == N) {",
            "\t\t\thh = 0;",
            "\t\t}",
            "\t\tst[t] = false;",
            "\t\tfor (int i = h[t]; ~i; i = ne[i]) {",
            "\t\t\tint v = e[i];",
            "\t\t\tif (f[i] && d[v] > d[t] + w[i]) {",
            "\t\t\t\td[v] = d[t] + w[i];",
            "\t\t\t\tpre[v] = i;",
            "\t\t\t\tincf[v] = min(f[i], incf[t]);",
            "\t\t\t\tif (!st[v]) {",
            "\t\t\t\t\tq[tt++] = v;",
            "\t\t\t\t\tif (tt == N) {",
            "\t\t\t\t\t\ttt = 0;",
            "\t\t\t\t\t}",
            "\t\t\t\t\tst[v] = true;",
            "\t\t\t\t}",
            "\t\t\t}",
            "\t\t}",
            "\t}",
            "\treturn d[T] != INF;",
            "}",
            "",
            "void cost_flow(int& flow, int& cost) {",
            "\t// flow存储流量，cost存储费用",
            "\tflow = cost = 0;",
            "\twhile (spfa()) {",
            "\t\tint t = incf[T];",
            "\t\tflow += t;",
            "\t\tcost += t * d[T];",
            "\t\tfor (int i = T; i != S; i = e[pre[i] ^ 1]) {",
            "\t\t\tf[pre[i]] -= t;",
            "\t\t\tf[pre[i] ^ 1] += t;",
            "\t\t}",
            "\t}",
            "}",
            "$0"
        ]
    },
    "int 费用流": {
        "prefix": "int cost flow",
        "body": [
            "bool spfa() {",
            "\t// 找距离最短的增广路",
            "\tint hh = 0, tt = 1;",
            "\tmemset(d, 0x3f, sizeof d);",
            "\tq[0] = S, d[S] = 0, incf[S] = INF;",
            "\twhile (hh != tt) {",
            "\t\tint t = q[hh++];",
            "\t\tif (hh == N) {",
            "\t\t\thh = 0;",
            "\t\t}",
            "\t\tst[t] = false;",
            "\t\tfor (int i = h[t]; ~i; i = ne[i]) {",
            "\t\t\tint v = e[i];",
            "\t\t\tif (f[i] && d[v] > d[t] + w[i]) {",
            "\t\t\t\td[v] = d[t] + w[i];",
            "\t\t\t\tpre[v] = i;",
            "\t\t\t\tincf[v] = min(f[i], incf[t]);",
            "\t\t\t\tif (!st[v]) {",
            "\t\t\t\t\tq[tt++] = v;",
            "\t\t\t\t\tif (tt == N) {",
            "\t\t\t\t\t\ttt = 0;",
            "\t\t\t\t\t}",
            "\t\t\t\t\tst[v] = true;",
            "\t\t\t\t}",
            "\t\t\t}",
            "\t\t}",
            "\t}",
            "\treturn d[T] != INF;",
            "}",
            "",
            "int cost_flow() {",
            "\t// 存储费用",
            "\tint cost = 0;",
            "\twhile (spfa()) {",
            "\t\tint t = incf[T];",
            "\t\tcost += t * d[T];",
            "\t\tfor (int i = T; i != S; i = e[pre[i] ^ 1]) {",
            "\t\t\tf[pre[i]] -= t;",
            "\t\t\tf[pre[i] ^ 1] += t;",
            "\t\t}",
            "\t}",
            "\treturn cost;",
            "}",
            "$0"
        ]
    },
    "dinic 最大流": {
        "prefix": "dinic max flow",
        "body": [
            "bool bfs() {",
            "\t// 创建分层图",
            "\tint hh = 0, tt = 0;",
            "\tmemset(d, -1, sizeof d);",
            "\tq[0] = S, d[S] = 0, cur[S] = h[S];",
            "\twhile (hh <= tt) {",
            "\t\tint t = q[hh++];",
            "\t\tfor (int i = h[t]; ~i; i = ne[i]) {",
            "\t\t\tint v = e[i];",
            "\t\t\tif (d[v] == -1 && f[i]) {",
            "\t\t\t\td[v] = d[t] + 1;",
            "\t\t\t\tcur[v] = h[v];",
            "\t\t\t\tif (v == T) {",
            "\t\t\t\t\treturn true;",
            "\t\t\t\t}",
            "\t\t\t\tq[++tt] = v;",
            "\t\t\t}",
            "\t\t}",
            "\t}",
            "\t// 没有增广路",
            "\treturn false;",
            "}",
            "",
            "int find(int u, int limit) {",
            "\t// 在残留网络中增广",
            "\tif (u == T) {",
            "\t\treturn limit;",
            "\t}",
            "\tint flow = 0;",
            "\tfor (int i = cur[u]; ~i && flow < limit; i = ne[i]) {",
            "\t\t// 当前弧优化",
            "\t\tcur[u] = i;",
            "\t\tint v = e[i];",
            "\t\tif (d[v] == d[u] + 1 && f[i]) {",
            "\t\t\tint t = find(v, min(f[i], limit - flow));",
            "\t\t\tif (!t) {",
            "\t\t\t\td[v] = -1;",
            "\t\t\t}",
            "\t\t\tf[i] -= t;",
            "\t\t\tf[i ^ 1] += t;",
            "\t\t\tflow += t;",
            "\t\t}",
            "\t}",
            "\treturn flow;",
            "}",
            "",
            "int dinic() {",
            "\tint r = 0, flow = 0;",
            "\twhile (bfs())",
            "\t\twhile (flow = find(S, INF)) {",
            "\t\t\tr += flow;",
            "\t\t}",
            "\treturn r;",
            "}",
            "$0"
        ]
    },
    "匈牙利算法": {
        "prefix": "xiongyali hungarian",
        "body": [
            "bool find(int x) {",
            "\tfor (int i = h[x]; i != -1; i = ne[i]) {",
            "\t\tint j = e[i];",
            "\t\tif (!st[j]) {",
            "\t\t\tst[j] = true;",
            "\t\t\tif (match[j] == 0 || find(match[j])) {",
            "\t\t\t\tmatch[j] = x;",
            "\t\t\t\treturn true;",
            "\t\t\t}",
            "\t\t}",
            "\t}",
            "",
            "\treturn false;",
            "}",
            "$0"
        ]
    },
    "tarjan - e-无向图双连通分量": {
        "prefix": "tarjan e-DCC",
        "body": [
            "void tarjan(int u, int from) {",
            "\t\tdfn[u] = low[u] = ++timestamp;",
            "\t\tstk[++top] = u;",
            "",
            "\t\tfor (int i = h[u]; ~i; i = ne[i]) {",
            "\t\t\t\tint j = e[i];",
            "\t\t\t\tif (!dfn[j]) {",
            "\t\t\t\t\t\ttarjan(j, i);",
            "\t\t\t\t\t\tlow[u] = min(low[u], low[j]);",
            "\t\t\t\t\t\tif (dfn[u] < low[j]) {",
            "\t\t\t\t\t\t\t\tis_bridge[i] = is_bridge[i ^ 1] = true;",
            "\t\t\t\t\t\t}",
            "\t\t\t\t} else if (i != (from ^ 1)) {",
            "\t\t\t\t\t\tlow[u] = min(low[u], dfn[j]);",
            "\t\t\t\t}",
            "\t\t}",
            "",
            "\t\tif (dfn[u] == low[u]) {",
            "\t\t\t\t++dcc_cnt;",
            "\t\t\t\tint y;",
            "\t\t\t\tdo {",
            "\t\t\t\t\t\ty = stk[top--];",
            "\t\t\t\t\t\tid[y] = dcc_cnt;",
            "\t\t\t\t} while (y != u);",
            "\t\t}",
            "}",
            "$0"
        ]
    },
    "tarjan - v-无向图双连通分量": {
        "prefix": "tarjan v-DCC",
        "body": [
            "void tarjan(int u) {",
            "\t\tdfn[u] = low[u] = ++timestamp;",
            "\t\tstk[++top] = u;",
            "",
            "\t\tif (u == root && h[u] == -1) {",
            "\t\t\t\tdcc_cnt++;",
            "\t\t\t\tdcc[dcc_cnt].push_back(u);",
            "\t\t\t\treturn;",
            "\t\t}",
            "",
            "\t\tint cnt = 0;",
            "\t\tfor (int i = h[u]; ~i; i = ne[i]) {",
            "\t\t\t\tint j = e[i];",
            "\t\t\t\tif (dfn[j]) {",
            "\t\t\t\t\t\tlow[u] = min(low[u], dfn[j]);",
            "\t\t\t\t\t\tcontinue;",
            "\t\t\t\t}",
            "\t\t\t\ttarjan(j);",
            "\t\t\t\tlow[u] = min(low[u], low[j]);",
            "\t\t\t\tif (dfn[u] <= low[j]) {",
            "\t\t\t\t\t\tcnt++;",
            "\t\t\t\t\t\tif (u != root || cnt > 1) {",
            "\t\t\t\t\t\t\t\tcut[u] = true;",
            "\t\t\t\t\t\t}",
            "\t\t\t\t\t\t++dcc_cnt;",
            "\t\t\t\t\t\tint y;",
            "\t\t\t\t\t\tdo {",
            "\t\t\t\t\t\t\t\ty = stk[top--];",
            "\t\t\t\t\t\t\t\tdcc[dcc_cnt].push_back(y);",
            "\t\t\t\t\t\t} while (y != j);",
            "\t\t\t\t\t\tdcc[dcc_cnt].push_back(u);",
            "\t\t\t\t}",
            "\t\t}",
            "}",
            "$0"
        ]
    },
    "tarjan - 有向图强连通分量": {
        "prefix": "tarjan SCC",
        "body": [
            "void tarjan(int u) {",
            "\t\tdfn[u] = low[u] = ++timestamp;",
            "\t\tstk[++top] = u, in_stk[u] = true;",
            "",
            "\t\tfor (int i = h[u]; ~i; i = ne[i]) {",
            "\t\t\t\tint j = e[i];",
            "\t\t\t\tif (!dfn[j]) {",
            "\t\t\t\t\t\ttarjan(j);",
            "\t\t\t\t\t\tlow[u] = min(low[u], low[j]);",
            "\t\t\t\t} else if (in_stk[j]) {",
            "\t\t\t\t\t\tlow[u] = min(low[u], dfn[j]);",
            "\t\t\t\t}",
            "\t\t}",
            "",
            "\t\tif (dfn[u] == low[u]) {",
            "\t\t\t\t++scc_cnt;",
            "\t\t\t\tint y;",
            "\t\t\t\tdo {",
            "\t\t\t\t\t\ty = stk[top--];",
            "\t\t\t\t\t\tin_stk[y] = false;",
            "\t\t\t\t\t\tid[y] = scc_cnt;",
            "\t\t\t\t} while (y != u);",
            "\t\t}",
            "}",
            "$0"
        ]
    },
    "lca 倍增法": {
        "prefix": "lca beizeng",
        "body": [
            "void bfs(int root) {",
            "\t\t// 预处理倍增数组",
            "\t\tmemset(depth, 0x3f, sizeof depth);",
            "\t\t// depth存储节点所在层数",
            "\t\tdepth[0] = 0, depth[root] = 1;",
            "\t\tint hh = 0, tt = 0;",
            "\t\tq[0] = root;",
            "\t\twhile (hh <= tt) {",
            "\t\t\t\tint t = q[hh++];",
            "\t\t\t\tfor (int i = h[t]; ~i; i = ne[i]) {",
            "\t\t\t\t\t\tint j = e[i];",
            "\t\t\t\t\t\tif (depth[j] > depth[t] + 1) {",
            "\t\t\t\t\t\t\t\tdepth[j] = depth[t] + 1;",
            "\t\t\t\t\t\t\t\tq[++tt] = j;",
            "\t\t\t\t\t\t\t\t// j的第二次幂个父节点",
            "\t\t\t\t\t\t\t\tfa[j][0] = t;",
            "\t\t\t\t\t\t\t\tfor (int k = 1; k <= 15; ++k) {",
            "\t\t\t\t\t\t\t\t\t\tfa[j][k] = fa[fa[j][k - 1]][k - 1];",
            "\t\t\t\t\t\t\t\t}",
            "\t\t\t\t\t\t}",
            "\t\t\t\t}",
            "\t\t}",
            "}",
            "",
            "int lca(int a, int b) {",
            "\t\t// 返回a和b的最近公共祖先",
            "\t\tif (depth[a] < depth[b]) {",
            "\t\t\t\tswap(a, b);",
            "\t\t}",
            "\t\tfor (int k = 15; k >= 0; --k) {",
            "\t\t\t\tif (depth[fa[a][k]] >= depth[b]) {",
            "\t\t\t\t\t\ta = fa[a][k];",
            "\t\t\t\t}",
            "\t\t}",
            "\t\tif (a == b) {",
            "\t\t\t\treturn a;",
            "\t\t}",
            "\t\tfor (int k = 15; k >= 0; k--) {",
            "\t\t\t\tif (fa[a][k] != fa[b][k]) {",
            "\t\t\t\t\t\ta = fa[a][k];",
            "\t\t\t\t\t\tb = fa[b][k];",
            "\t\t\t\t}",
            "\t\t}",
            "\t\treturn fa[a][0];",
            "}",
            "$0"
        ]
    },
    "fft": {
        "prefix": "fft",
        "body": [
            "struct Complex {",
            "\tdouble x, y;",
            "\tComplex operator+(const Complex& t) const { return {x + t.x, y + t.y}; }",
            "\tComplex operator-(const Complex& t) const { return {x - t.x, y - t.y}; }",
            "\tComplex operator*(const Complex& t) const {",
            "\t\treturn {x * t.x - y * t.y, x * t.y + y * t.x};",
            "\t}",
            "};",
            "int rev[N], bit, tot;\t// tot = 1 << bit",
            "",
            "void fft(Complex a[], int inv) {",
            "\tfor (int i = 0; i < tot; ++i) {",
            "\t\trev[i] = (rev[i >> 1] >> 1) | ((i & 1) << (bit - 1));",
            "\t}",
            "\tfor (int i = 0; i < tot; ++i) {",
            "\t\tif (i < rev[i]) {",
            "\t\t\tswap(a[i], a[rev[i]]);",
            "\t\t}",
            "\t}",
            "\tfor (int mid = 1; mid < tot; mid <<= 1) {",
            "\t\tauto w1 = Complex({cos(PI / mid), inv * sin(PI / mid)});",
            "\t\tfor (int i = 0; i < tot; i += mid * 2) {",
            "\t\t\tauto wk = Complex({1, 0});",
            "\t\t\tfor (int j = 0; j < mid; j++, wk = wk * w1) {",
            "\t\t\t\tauto x = a[i + j];",
            "\t\t\t\tauto y = wk * a[i + j + mid];",
            "\t\t\t\ta[i + j] = x + y;",
            "\t\t\t\ta[i + j + mid] = x - y;",
            "\t\t\t}",
            "\t\t}",
            "\t}",
            "}",
            "$0"
        ]
    },
    "bsgs": {
        "prefix": "bsgs",
        "body": [
            "int bsgs(int a, int b, int p) {",
            "\t// a ^ x ≡ b (mod p) 的最小非负整数解",
            "\tif (b == 1) {",
            "\t\treturn 0;",
            "\t}",
            "\tint k = sqrt(p) + 1;",
            "\tunordered_map<int, int> hash;",
            "\tfor (int i = 0, j = b; i < k; ++i) {",
            "\t\thash[j] = i;",
            "\t\tj = (LL)j * a % p;",
            "\t}",
            "\tint ak = 1;",
            "\tfor (int i = 0; i < k; ++i) {",
            "\t\tak = (LL)ak * a % p;",
            "\t}",
            "\tfor (int i = 1, j = ak; i <= k; ++i) {",
            "\t\tif (hash.count(j) && (LL)i * k >= hash[j]) {",
            "\t\t\treturn (LL)i * k - hash[j];",
            "\t\t}",
            "\t\tj = (LL)j * ak % p;",
            "\t}",
            "\treturn -1;",
            "}",
            "$0"
        ]
    },
    "andrew - 求凸包": {
        "prefix": "andrew convex",
        "body": [
            "int stk[N], top;",
            "PDD q[N];",
            "bool used[N];",
            "",
            "PDD operator-(PDD a, PDD b)\t// 向量减法",
            "{",
            "\treturn {a.x - b.x, a.y - b.y};",
            "}",
            "",
            "double operator*(PDD a, PDD b) {",
            "\t// 叉积、外积",
            "\treturn a.x * b.y - a.y * b.x;",
            "}",
            "",
            "double operator&(PDD a, PDD b) {",
            "\t// 内积、点积",
            "\treturn a.x * b.x + a.y * b.y;",
            "}",
            "",
            "double area(PDD a, PDD b, PDD c) {",
            "\t// 以a, b, c为顶点的有向三角形面积",
            "\treturn (b - a) * (c - a);",
            "}",
            "",
            "double get_len(PDD a) {",
            "\t// 求向量长度",
            "\treturn sqrt(a & a);",
            "}",
            "",
            "double get_dist(PDD a, PDD b) {",
            "\t// 求两个点之间的距离",
            "\treturn get_len(b - a);",
            "}",
            "",
            "void andrew() {",
            "\t// Andrew算法, 凸包节点编号逆时针存于stk中，下标从0开始",
            "\tsort(q, q + n);",
            "\tfor (int i = 0; i < n; i++) {",
            "\t\twhile (top >= 2 && area(q[stk[top - 2]], q[stk[top - 1]], q[i]) <= 0) {",
            "\t\t\tif (area(q[stk[top - 2]], q[stk[top - 1]], q[i]) < 0) {",
            "\t\t\t\tused[stk[--top]] = false;",
            "\t\t\t} else {",
            "\t\t\t\t--top;",
            "\t\t\t}",
            "\t\t}",
            "\t\tstk[top++] = i;",
            "\t\tused[i] = true;",
            "\t}",
            "\tused[0] = false;",
            "\tfor (int i = n - 1; i >= 0; --i) {",
            "\t\tif (used[i]) {",
            "\t\t\tcontinue;",
            "\t\t}",
            "\t\twhile (top >= 2 && area(q[stk[top - 2]], q[stk[top - 1]], q[i]) <= 0) {",
            "\t\t\t--top;",
            "\t\t}",
            "\t\tstk[top++] = i;",
            "\t}",
            "\t// 起点重复添加了一次，将其去掉",
            "\t--top;",
            "}",
            "$0"
        ]
    },
    "半平面交": {
        "prefix": "half",
        "body": [
            "struct Line {",
            "\t// 直线上的两个点",
            "\tPDD st, ed;",
            "} line[N];",
            "",
            "// 双端队列",
            "int q[N];",
            "",
            "int sign(double x) {",
            "\t// 符号函数",
            "\tif (fabs(x) < eps) {",
            "\t\treturn 0;",
            "\t}",
            "\tif (x < 0) {",
            "\t\treturn -1;",
            "\t}",
            "\treturn 1;",
            "}",
            "",
            "int dcmp(double x, double y) {",
            "\t// 比较两数大小",
            "\tif (fabs(x - y) < eps) {",
            "\t\treturn 0;",
            "\t}",
            "\tif (x < y) {",
            "\t\treturn -1;",
            "\t}",
            "\treturn 1;",
            "}",
            "",
            "PDD operator+(PDD a, PDD b) {",
            "\t// 向量加法",
            "\treturn {a.x + b.x, a.y + b.y};",
            "}",
            "",
            "PDD operator-(PDD a, PDD b) {",
            "\t// 向量减法",
            "\treturn {a.x - b.x, a.y - b.y};",
            "}",
            "",
            "double operator*(PDD a, PDD b) {",
            "\t// 外积、叉积",
            "\treturn a.x * b.y - a.y * b.x;",
            "}",
            "",
            "PDD operator*(PDD a, double t) {",
            "\t// 向量数乘",
            "\treturn {a.x * t, a.y * t};",
            "}",
            "",
            "double area(PDD a, PDD b, PDD c) {",
            "\t// 以a, b, c为顶点的有向三角形面积",
            "\treturn (b - a) * (c - a);",
            "}",
            "",
            "PDD get_line_intersection(PDD p, PDD v, PDD q, PDD w) {",
            "\t// 求两直线交点：p + vt, q + wt",
            "\tauto u = p - q;",
            "\tauto t = w * u / (v * w);",
            "\treturn p + v * t;",
            "}",
            "",
            "PDD get_line_intersection(Line a, Line b) {",
            "\t// 求两直线交点",
            "\treturn get_line_intersection(a.st, a.ed - a.st, b.st, b.ed - b.st);",
            "}",
            "",
            "bool on_right(Line& a, Line& b, Line& c) {",
            "\t// bc的交点是否在a的右侧",
            "\tauto o = get_line_intersection(b, c);",
            "\treturn sign(area(a.st, a.ed, o)) <= 0;",
            "}",
            "",
            "double get_angle(const Line& a) {",
            "\t// 求直线的极角大小",
            "\treturn atan2(a.ed.y - a.st.y, a.ed.x - a.st.x);",
            "}",
            "",
            "bool cmp(const Line& a, const Line& b) {",
            "\t// 将所有直线按极角排序",
            "\tdouble A = get_angle(a);",
            "\tdouble B = get_angle(b);",
            "\tif (!dcmp(A, B)) {",
            "\t\treturn area(a.st, a.ed, b.ed) < 0;",
            "\t}",
            "\treturn A < B;",
            "}",
            "",
            "void half_plane_intersection() {",
            "\tsort(line, line + cnt, cmp);",
            "\t// 半平面交，交集的边逆时针顺序存于q[]中",
            "\tint hh = 0, tt = -1;",
            "\tfor (int i = 0; i < cnt; ++i) {",
            "\t\tif (i && !dcmp(get_angle(line[i]), get_angle(line[i - 1]))) {",
            "\t\t\tcontinue;",
            "\t\t}",
            "\t\twhile (hh + 1 <= tt && on_right(line[i], line[q[tt - 1]], line[q[tt]])) {",
            "\t\t\t--tt;",
            "\t\t}",
            "\t\twhile (hh + 1 <= tt && on_right(line[i], line[q[hh]], line[q[hh + 1]])) {",
            "\t\t\t++hh;",
            "\t\t}",
            "\t\tq[++tt] = i;",
            "\t}",
            "\twhile (hh + 1 <= tt && on_right(line[q[hh]], line[q[tt - 1]], line[q[tt]])) {",
            "\t\t--tt;",
            "\t}",
            "\twhile (hh + 1 <= tt && on_right(line[q[tt]], line[q[hh]], line[q[hh + 1]])) {",
            "\t\t++hh;",
            "\t}",
            "",
            "\tq[++tt] = q[hh];",
            "\t// 交集的边逆时针顺序存于q[]中",
            "",
            "\t// TODO: 求出半平面交后，根据题目要求求答案",
            "\t$0",
            "}"
        ]
    },
    "计算几何常用函数": {
        "prefix": "cgl",
        "body": [
            "int sign(double x) {",
            "\tif (fabs(x) < eps) {",
            "\t\treturn 0;",
            "\t}",
            "\tif (x < 0) {",
            "\t\treturn -1;",
            "\t}",
            "\treturn 1;",
            "}",
            "",
            "int dcmp(double x, double y) {",
            "\t// 比较两数大小",
            "\tif (fabs(x - y) < eps) {",
            "\t\treturn 0;",
            "\t}",
            "\tif (x < y) {",
            "\t\treturn -1;",
            "\t}",
            "\treturn 1;",
            "}",
            "",
            "PDD operator+(PDD a, PDD b) {",
            "\t// 向量加法",
            "\treturn {a.x + b.x, a.y + b.y};",
            "}",
            "",
            "PDD operator-(PDD a, PDD b) {",
            "\t//\t向量减法",
            "\treturn {a.x - b.x, a.y - b.y};",
            "}",
            "",
            "PDD operator*(PDD a, double t) {",
            "\t// 向量数乘",
            "\treturn {a.x * t, a.y * t};",
            "}",
            "",
            "PDD operator/(PDD a, double t) {",
            "\t// 向量除以常数",
            "\treturn {a.x / t, a.y / t};",
            "}",
            "",
            "double operator*(PDD a, PDD b) {",
            "\t// 外积、叉积",
            "\treturn a.x * b.y - a.y * b.x;",
            "}",
            "",
            "double operator&(PDD a, PDD b) {",
            "\t// 内积、点积",
            "\treturn a.x * b.x + a.y * b.y;",
            "}",
            "",
            "double area(PDD a, PDD b, PDD c) {",
            "\t// 以a, b, c为顶点的有向三角形面积",
            "\treturn (b - a) * (c - a);",
            "}",
            "",
            "double get_len(PDD a) {",
            "\t// 求向量长度",
            "\treturn sqrt(a & a);",
            "}",
            "",
            "double get_dist(PDD a, PDD b) {",
            "\t// 求两个点之间的距离",
            "\treturn get_len(b - a);",
            "}",
            "",
            "double project(PDD a, PDD b, PDD c) {",
            "\t// 求向量ac在向量ab上的投影",
            "\treturn ((c - a) & (b - a)) / get_len(b - a);",
            "}",
            "",
            "PDD rotate(PDD a, double b) {",
            "\t// 向量a逆时针旋转角度b",
            "\treturn {a.x * cos(b) + a.y * sin(b), -a.x * sin(b) + a.y * cos(b)};",
            "}",
            "",
            "PDD norm(PDD a) {",
            "\t// 矩阵标准化（将长度变成1）",
            "\treturn a / get_len(a);",
            "}",
            "",
            "bool on_segment(PDD p, PDD a, PDD b) {",
            "\t// 点p是否在线段ab上（包含端点a、b）",
            "\treturn !sign((p - a) * (p - b)) && sign((p - a) & (p - b)) <= 0;",
            "}",
            "",
            "PDD get_line_intersection(PDD p, PDD v, PDD q, PDD w) {",
            "\t// 求两直线交点：p + vt, q + wt",
            "\tauto u = p - q;",
            "\tauto t = w * u / (v * w);",
            "\treturn p + v * t;",
            "}",
            "$0"
        ]
    },
    "simpson - 辛普森积分": {
        "prefix": "simpson",
        "body": [
            "double f(double x) {",
            "\t// TODO: 实现所求的函数",
            "\t$0",
            "}",
            "",
            "double simpson(double l, double r) {",
            "\t// 辛普森积分公式",
            "\tauto mid = (l + r) / 2;",
            "\treturn (r - l) * (f(l) + 4 * f(mid) + f(r)) / 6;",
            "}",
            "",
            "double asr(double l, double r, double s) {",
            "\t// 自适应",
            "\tauto mid = (l + r) / 2;",
            "\tdouble left = simpson(l, mid);",
            "\tdouble right = simpson(mid, r);",
            "\tif (fabs(left + right - s) < eps) {",
            "\t\treturn left + right;",
            "\t}",
            "\treturn asr(l, mid, left) + asr(mid, r, right);",
            "}",
            "$0"
        ]
    },
    "gauss - 高斯消元（浮点值）": {
        "prefix": "gauss double",
        "body": [
            "int gauss() {",
            "\t// 高斯消元，答案存于a[i][n]中，0 <= i < n",
            "\tint c, r;",
            "\tfor (c = 0, r = 0; c < n; ++c) {",
            "\t\tint t = r;",
            "\t\tfor (int i = r; i < n; ++i) {",
            "\t\t\t// 找绝对值最大的行",
            "\t\t\tif (fabs(a[i][c]) > fabs(a[t][c])) {",
            "\t\t\t\tt = i;",
            "\t\t\t}",
            "\t\t}",
            "",
            "\t\tif (fabs(a[t][c]) < eps) {",
            "\t\t\tcontinue;",
            "\t\t}",
            "",
            "\t\tfor (int i = c; i <= n; ++i) {",
            "\t\t\t// 将绝对值最大的行换到最顶端",
            "\t\t\tswap(a[t][i], a[r][i]);",
            "\t\t}",
            "\t\tfor (int i = n; i >= c; --i) {",
            "\t\t\t// 将当前行的首位变成1",
            "\t\t\ta[r][i] /= a[r][c];",
            "\t\t}",
            "\t\tfor (int i = r + 1; i < n; ++i) {",
            "\t\t\t// 用当前行将下面所有的列消成0",
            "\t\t\tif (fabs(a[i][c]) > eps) {",
            "\t\t\t\tfor (int j = n; j >= c; --j) {",
            "\t\t\t\t\ta[i][j] -= a[r][j] * a[i][c];",
            "\t\t\t\t}",
            "\t\t\t}",
            "\t\t}",
            "",
            "\t\t++r;",
            "\t}",
            "",
            "\tif (r < n) {",
            "\t\tfor (int i = r; i < n; i++) {",
            "\t\t\tif (fabs(a[i][n]) > eps) {",
            "\t\t\t\t// 无解",
            "\t\t\t\treturn 2;",
            "\t\t\t}",
            "\t\t}",
            "\t\t// 有无穷多组解",
            "\t\treturn 1;",
            "\t}",
            "",
            "\tfor (int i = n - 1; i >= 0; --i)",
            "\t\tfor (int j = i + 1; j < n; ++j) {",
            "\t\t\ta[i][n] -= a[i][j] * a[j][n];",
            "\t\t}",
            "",
            "\t// 有唯一解",
            "\treturn 0;",
            "}",
            "$0"
        ]
    },
    "gauss - 高斯消元（布尔值）": {
        "prefix": "gauss bool",
        "body": [
            "int gauss() {",
            "\t// 高斯消元，答案存于a[i][n]中，0 <= i < n",
            "\tint c, r;",
            "\tfor (c = 0, r = 0; c < n; ++c) {",
            "\t\tint t = r;",
            "\t\tfor (int i = r; i < n; ++i) {",
            "\t\t\t// 找非零行",
            "\t\t\tif (a[i][c]) {",
            "\t\t\t\tt = i;",
            "\t\t\t}",
            "\t\t}",
            "",
            "\t\tif (!a[t][c]) {",
            "\t\t\tcontinue;",
            "\t\t}",
            "",
            "\t\tfor (int i = c; i <= n; ++i) {",
            "\t\t\t// 将非零行换到最顶端",
            "\t\t\tswap(a[r][i], a[t][i]);",
            "\t\t}",
            "\t\tfor (int i = r + 1; i < n; ++i) {",
            "\t\t\t// 用当前行将下面所有的列消成0",
            "\t\t\tif (a[i][c]) {",
            "\t\t\t\tfor (int j = n; j >= c; --j) {",
            "\t\t\t\t\ta[i][j] ^= a[r][j];",
            "\t\t\t\t}",
            "\t\t\t}",
            "\t\t}",
            "",
            "\t\t++r;",
            "\t}",
            "",
            "\tif (r < n) {",
            "\t\tfor (int i = r; i < n; ++i) {",
            "\t\t\tif (a[i][n]) {",
            "\t\t\t\t// 无解",
            "\t\t\t\treturn 2;",
            "\t\t\t}",
            "\t\t}",
            "\t\t// 有多组解",
            "\t\treturn 1;",
            "\t}",
            "",
            "\tfor (int i = n - 1; i >= 0; --i) {",
            "\t\tfor (int j = i + 1; j < n; ++j) {",
            "\t\t\ta[i][n] ^= a[i][j] * a[j][n];",
            "\t\t}",
            "\t}",
            "",
            "\t// 有唯一解",
            "\treturn 0;",
            "}",
            "$0"
        ]
    },
    "simulate_anneal 模拟退火": {
        "prefix": "simulate anneal",
        "body": [
            "double calc() {",
            "\t// TODO: 计算当前方案的值",
            "\t$0",
            "",
            "\t// 更新全局答案",
            "\tans = min(ans, res);",
            "\treturn res;",
            "}",
            "",
            "void simulate_anneal() {",
            "\t// 模拟退火, 逐渐降温",
            "\tfor (double t = 1e6; t > 1e-6; t *= 0.95) {",
            "\t\t// 原方案的值",
            "\t\tdouble x = calc();",
            "\t\t// TODO: 随机一个新方案",
            "",
            "\t\t// 新方案的值",
            "\t\tdouble y = calc();",
            "\t\tdouble delta = y - x;",
            "",
            "\t\t// 新方案更好，则必选新方案；否则以一定概率选新方案",
            "\t\tif (exp(-delta / t) > (double)rand() / RAND_MAX) {",
            "\t\t\t// TODO: 换成新方案",
            "\t\t}",
            "\t}",
            "}"
        ]
    },
    "void add - 加边，不带权": {
        "prefix": "void add(",
        "body": [
            "void add(int a, int b) {",
            "\t// 添加一条边a->b",
            "\te[idx] = b, ne[idx] = h[a], h[a] = idx++;",
            "}",
            "$0"
        ]
    },
    "void add - 加边，带权": {
        "prefix": "void add(",
        "body": [
            "void add(int a, int b, int c) {",
            "\t// 添加一条边a->b，边权为c",
            "\te[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx++;",
            "}",
            "$0"
        ]
    },
    "void add - 加边，最大流": {
        "prefix": "void add(",
        "body": [
            "void add(int a, int b, int c) {",
            "\t// 添加一条边a->b，容量为c；同时添加一条反向边",
            "\te[idx] = b, f[idx] = c, ne[idx] = h[a], h[a] = idx++;",
            "\te[idx] = a, f[idx] = 0, ne[idx] = h[b], h[b] = idx++;",
            "}",
            "$0"
        ]
    },
    "void add - 加边，费用流": {
        "prefix": "void add(",
        "body": [
            "void add(int a, int b, int c, int d) {",
            "\t// 添加一条边a->b，容量为c，费用为d；同时增加一条反向边",
            "\te[idx] = b, f[idx] = c, w[idx] = d, ne[idx] = h[a], h[a] = idx++;",
            "\te[idx] = a, f[idx] = 0, w[idx] = -d, ne[idx] = h[b], h[b] = idx++;",
            "}",
            "$0"
        ]
    }
}
